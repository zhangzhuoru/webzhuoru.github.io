## **Ajax**

- Ajax 是一种异步请求数据的一种技术，对于改善用户的体验和程序的性能很有帮助。 简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。Ajax的目的是提高用户体验，较少网络数据的传输量。
- ajax中 get 和 post 有什么区别:
  - get和post都是数据提交的方式。
  - get的数据是通过网址问号后边拼接的字符串进行传递的。post是通过一个HTTP包体进行传递数据的。
  - get的传输量是有限制的，post是没有限制的。
  - get的安全性可能没有post高，所以我们一般用get来获取数据，post一般用来修改数据。

```
var xhr = null;//创建对象 
if(window.XMLHttpRequest){
       xhr = new XMLHttpRequest();
}else{
       xhr = new ActiveXObject("Microsoft.XMLHTTP");
}
xhr.onreadystatechange = function () {
    // 这里的函数异步执行
    if (xhr.readyState == 4) {
        if (xhr.status == 200) {
            alert(xhr.responseText)
        }
    }
}
xhr.open("GET", "/api", false)
xhr.send(null)
```

第一家公司离职原因，项目简单，日常摸鱼，我想在自己还能学，还能拼地时候，多学点。

第二家公司离职原因，公司因为疫情原因呢，内部重组了，项目组解散了，虽然很难接受，但我对公司还是心存感激的，比较过去一年公司让我飞速成长了，也让我有能力为新公司带来价值

第三家公司离职原因，这份工作和我设想的不一样，进去前讲的是前后端分离，进去后发现前端写完，后台还没忙完，需要前端后端一起写，因为其实我对自己是有比较清晰的，了解的，我更擅长于做前端，而不是做后台。

# 优点

我一个做事情全力以赴的人，一旦确立了目标，我会用上我全部的力量直到成功，即使加班了，我也不会遗憾。

比方说，前段时间我为了做一个紧急的项目，连续两个星期没有休息日把项目做完了

## 缺点

我的公开演讲能力，比较差。在公共地方讲话的时候，我会感到非常的紧张，不过谈论到我比较熟悉的领域，我是比较放得开的，所以当我需要公开发言的时候，我就必须要准备的十分地充分

## post请求类型有哪些？

## get和post具体应用场景说一下？

## 1.介绍一下自己;

## 2.做过什么项目?你觉得最好的项目是什么?;

恒电大数据平台，有登录模块，账号权限管理模块，课程管理模块，实验管理模块，成绩管理模块，

## 5.写过响应式布局?讲一下媒体查询,百分比,rem,视口 viewport;

不同屏幕分辨率的终端上浏览网页的不同展示方式

6.讲一下弹性布局?(弹性布局这个非常重要)怎么去实现一排子项目平分父元素( flex-grow:1)

 

7.讲下样式预处理语言(这个答less,讲一下变量样式嵌套,还有一些函数);

less @

sass $

8.讲一下工程化工具 webpack,怎么用(答了enty, output, loaderplugin);

## 9.项目写过ES6,讲讲ES6;

1）let声明变量和const声明常量，两个都有块级作用域 　ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明

　　2）箭头函数 　ES6中的函数定义不再使用关键字function()，而是利用了()=>来进行定义

**14.箭头函数This指向问题？**

- 默认指向在定义它时,它所处的对象,而不是执行时的对象,定义它的时候,可能环境是window（即继承父级的this）。

　　3）模板字符串 　模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串

　　4）解构赋值 　ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值

　　5）for of循环 　for...of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串

　　6）import、export导入导出 　ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用

　　7）set数据结构 　Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数

　　8）... 展开运算符 　可以将数组或对象里面的值展开；还可以将多个值收集为一个变量

　　9）修饰器 @ 　decorator是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数

　　10）class 类的继承 　ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念

　　11）async、await 　使用 async/await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性 　async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成

　　12）promise 　Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大

10如何优化网站。

## 11.js闭包,

闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。

闭包就是能读取其他函数内部变量的函数，使用它就是想在一个函数内部也有权限，去访问另一个函数内部的变量并且让这些变量的值始终保持在内存中。

好处的话，就是说，保护函数内的变量安全，实现封装，防止变量流入其他环境发生命名冲突，还有就是在内存中维持一个变量，可以做缓存，最后匿名自执行函数减少内存消耗，

坏处就是在浏览器中会有一个bug，就是被应用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏

解决方法呢，就是在使用完变量之后，手动的赋值为null

htt协议,

Css,

数据结构和前端框架(主要是vue)

是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter， getter，在数据变动时发布消息 给订阅者，触发相应的监听回调。  

## [HTTP与HTTPS的区别](https://www.cnblogs.com/wqhwe/p/5407468.html)

[“约见”面试官系列之常见面试题第二篇说说rem（建议收藏）_歌谣的博客-CSDN博客_rem面试题](https://blog.csdn.net/weixin_43392489/article/details/108350993?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0.no_search_link&spm=1001.2101.3001.4242)

缓存

## $nextTick

是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可 以在回调中获取更新后的 DOM  

## 原型，原型对象，原型链

 对象会有一个隐式的-proto-属性，指向原型对象，

实例找不到原型对象时，

构造函数有prototype属性指向原型对象，

原型对象有constructor指向构造函数

构造函数的对象.-proto-===构造函数.prototype

## 作用链和闭包

局部作用域找不到时，就会沿着作用域往上找，内部函数返回变量，外部就能获取到了

## 闭包的优缺点

用处：1.读取函数内部的变量；

```
       2.这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除。
```

优点：1:变量长期驻扎在内存中；

```
       2:避免全局变量的污染；

       3:私有成员的存在 ；
```

特性：1:函数套函数；

```
       2:内部函数可以直接使用外部函数的局部变量或参数；

       3:变量或参数不会被垃圾回收机制回收 GC；
```

缺点:

```
常驻内存 会增大内存的使用量 使用不当会造成内存泄露
```

## **11. cookies，sessionStorage和localStorage的区别？**

- 共同点：都是保存在浏览器端，且是同源的。
- 区别：
  - cookies是为了标识用户身份而存储在用户本地终端上的数据，始终在同源http请求中携带，即cookies在浏览器和服务器间来回传递，而sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存。
  - 存储大小的限制不同。cookie保存的数据很小，不能超过4k，而sessionstorage和localstorage保存的数据大，可达到5M。
  - 数据的有效期不同。cookie在设置的cookie过期时间之前一直有效，即使窗口或者浏览器关闭。sessionstorage仅在浏览器窗口关闭之前有效。localstorage始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。
  - 作用域不同。cookie在所有的同源窗口都是共享；sessionstorage不在不同的浏览器共享，即使同一页面；localstorage在所有同源窗口都是共享

## **8.Promise**

- Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。

- Promise对象有以下两个特点：

  - 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）
  - 一旦状态改变，就不会再变，任何时候都可以得到这个结果

- Promise 解决的痛点：

  - 回调地狱，代码难以维护
  - promise可以支持多个并发的请求，获取并发请求中的数据

- Promise使用方法：

  - 创造一个Promise实例
  - Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数
  - 可用Promise的try和catch方法预防异常

- Promise常用方法：

  - Promise.resolve(value)

  > 类方法，该方法返回一个以 value 值解析后的 Promise 对象如果这个值是个 thenable（即带有 then 方法），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回其他情况以该值为成功状态返回一个 Promise 对象

   

- Promise.reject

  > 类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected

   

  - Promise.prototype.then

> 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收

​    

```
- Promise.prototype.catch
> 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息
```


​    

```
- Promise.race
> 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败
```


​    

```
- Promise.all
> 类方法，多个 Promise 任务同时执行如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。 如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果
```


​    

- 存在的问题
  - promise一旦执行，无法中途取消
  - promise的错误无法在外部被捕捉到，只能在内部进行预判处理
  - promise的内如何执行，监测起来很难

## **7.再说一下Computed和Watch**

- Computed本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。
- Watch没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用unWatch手动注销哦。

## **17.Vue2.x组件通信有哪些方式？**

- 父子组件通信
  - 父->子props，子->父 $on、$emit
  - 获取父子组件实例 $parent、$children
  - Ref 获取实例的方式调用组件的属性或者方法
  - Provide、inject 官方不推荐使用，但是写组件库时很常用
- 兄弟组件通信
  - Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue
  - Vuex
- 跨级组件通信
  - Vuex
  - $attrs、$listeners
  - Provide、inject

## **20.hash路由和history路由实现原理说一下**

- location.hash的值实际就是URL中#后面的东西。
- history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。

## **6.你知道哪些状态码**

- HTTP状态码分类：
  - 1**：信息，服务器收到请求，需要请求者继续执行操作
  - 2**：成功，操作被成功接收并处理
  - 3**：重定向，需要进一步的操作以完成请求
  - 4**：客户端错误，请求包含语法错误或者无法完成请求
  - 5**：服务器错误，服务器在处理请求的过程中发生了错误
- 常见的HTTP状态码：
  - 200——OK，请求成功
  
  - 301——Moved Permanently，资源（网页等）被永久转移到其他URL
  
  - 302——Found，307——Temporary Redirect，临时重定向，请求的文档被临时移动到别处
  
  - 304——Not Modified，未修改，表示客户端缓存的版本是最近的
  
  - | 400  | Bad Request | 客户端请求的语法错误，服务器无法理解 |
    | ---- | ----------- | ------------------------------------ |
    |      |             |                                      |
  
  - 401——Unauthorized，请求要求用户的身份认证
  
  - 403——Forbidden，禁止，服务器理解客户端请求，但是拒绝处理此请求，通常是权限设置所致
  
  - 404——Not Found，请求的资源（网页等）不存在
  
  - | 408  | Request Time-out | 服务器等待客户端发送的请求时间过长，超时 |
    | ---- | ---------------- | ---------------------------------------- |
    |      |                  |                                          |
  
  - 500——Internal Server Error——内部服务器错误
  
  - 502——Bad Gateway，充当网关或代理的服务器从远端服务器接收到了一个无效的请求
  
  - 504——Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求

## **7.HTTP和HTTPS的区别**

- HTTP（Hyper Text Transfer Protocol，超文本传输协议）被用于在web浏览器和网站服务器之间传递信息，HTTP协议以明文的方式发送内容，不提供任何方式的数据加密，如果攻击者截取了web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号，密码等支付信息。
- HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer，安全套接字超文本传输协议），为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS，依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
- 区别：
  - HTTPS协议需要CA申请证书，一般免费证书比较少，所以需要一定费用
  - HTTP是超文本传输协议，信息室明文传输，HTTPS则是具有安全性的SSL加密传输协议
  - HTTP和HTTPS使用的是完全不同的连接方式，使用的端口号也不一样，前者是80，后者是443
  - HTTP连接很简单，是无状态的；HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，比较安全。
  - 谷歌搜索引擎算法中，比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中排名会更高

## v-if和v-show

v-if条件为真才会渲染，条件为假则不渲染，v-show 无论条件真假总会渲染，只是简单地基于 CSS 进行切换。

```
      一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。
```

```text
什么是服务端渲染（SSR）？谈一谈他的优缺点
```

### **解题思路：**

服务端渲染：

简单理解是将组件或页面通过服务器生成html字符串，再发送到浏览器，当用户第一次请求页面时，客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。



优点：

- 首屏渲染快
- 利于SEO
- 可以生成缓存片段，生成静态化文件

缺点:

- 服务端压力较大
- 开发条件受限
- 学习成本相对较高